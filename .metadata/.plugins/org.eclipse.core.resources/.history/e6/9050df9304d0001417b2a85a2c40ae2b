import java.awt.*; import java.awt.geom.Line2D; import java.io.*; import java.util.ArrayList; import javax.swing.JComponent; import javax.swing.JFrame;   public class KenKenComponent extends jcomponent {   public KenKenComponent(string fileName, jframe frame) throws ioexception { xOffset = 10; yOffset = 10; cellSize = 60; thin = new basicstroke(1.0F); thick = new basicstroke(5F); bufferedreader in = new bufferedreader(new filereader(fileName)); string str = in.readLine(); size = integer.parseInt(str); bottom = new boolean[size][size]; right = new boolean[size][size]; numbers = new int[size][size]; cages = new int[size][size]; targetNumber = new int[size][size]; operator = new char[size][size]; numColors = new color[size][size]; for(int row = 0; row < size; row++) { for(int column = 0; column < size; column++) numColors[row][column] = color.BLUE;   }   frame.setSize(cellSize * size + 2 * xOffset + 2, cellSize * size + 2 * yOffset + 29); frame.setTitle("KenKen"); frame.setDefaultCloseOperation(3); frame.setVisible(true); str = in.readLine(); numCages = integer.parseInt(str); cageTargetNumber = new int[numCages]; cageOperator = new char[numCages]; for(int i = 0; i < numCages; i++) { str = in.readLine(); string temp[] = str.split(","); int target = integer.parseInt(temp[0]); char op = temp[1].charAt(0); int numCells = integer.parseInt(temp[2]); for(int j = 0; j < numCells; j++) { str = in.readLine(); temp = str.split(","); int row = integer.parseInt(temp[0]); int column = integer.parseInt(temp[1]); cages[row][column] = i; numbers[row][column] = 0; if(j == 0) { targetNumber[row][column] = target; cageTargetNumber[i] = target; operator[row][column] = op; cageOperator[i] = op; } else { targetNumber[row][column] = -1; operator[row][column] = ' '; } }   }   in.close(); setLines(); frame.add(this); }   private void setLines() { for(int row = 0; row < size; row++) { for(int column = 0; column < size; column++) if(column == size - 1) right[row][column] = true; else right[row][column] = cages[row][column] != cages[row][column + 1];   }   for(int column = 0; column < size; column++) { for(int row = 0; row < size; row++) if(row == size - 1) bottom[row][column] = true; else bottom[row][column] = cages[row][column] != cages[row + 1][column];   }   }   public void setNumber(int nums[][]) { numbers = nums; checkRowColumn(); checkCages(); repaint(); }   public void paintComponent(graphics g) { graphics2d g2 = (graphics2d)g; g2.setColor(color.WHITE); g2.fillRect(0, 0, getWidth(), getHeight()); java.awt.geom.line2d.double line = new java.awt.geom.line2d.double(0.0D, 0.0D, 0.0D, 0.0D); g2.setColor(color.BLACK); for(int i = 0; i < size; i++) { g2.setStroke(thick); line.setLine(xOffset + i * cellSize, yOffset, xOffset + (i * cellSize + cellSize), yOffset); g2.draw(line); line.setLine(xOffset + i * cellSize, yOffset + size * cellSize, xOffset + (i * cellSize + cellSize), yOffset + size * cellSize); g2.draw(line); }   for(int i = 0; i < size; i++) { g2.setStroke(thick); line.setLine(xOffset, yOffset + i * cellSize, xOffset, yOffset + (i * cellSize + cellSize)); g2.draw(line); line.setLine(xOffset + size * cellSize, yOffset + i * cellSize, xOffset + size * cellSize, yOffset + (i * cellSize + cellSize)); g2.draw(line); }   for(int row = 0; row < size; row++) { for(int column = 0; column < size - 1; column++) { line.setLine(xOffset + (column + 1) * cellSize, yOffset + row * cellSize, xOffset + (column + 1) * cellSize, yOffset + (row + 1) * cellSize); if(right[row][column]) g2.setStroke(thick); else g2.setStroke(thin); g2.draw(line); }   }   for(int column = 0; column < size; column++) { for(int row = 0; row < size - 1; row++) { line.setLine(xOffset + column * cellSize, yOffset + (row + 1) * cellSize, xOffset + (column + 1) * cellSize, yOffset + (row + 1) * cellSize); if(bottom[row][column]) g2.setStroke(thick); else g2.setStroke(thin); g2.draw(line); }   }   g2.setStroke(thin); g2.setFont(new font("Dialog", 1, 14)); for(int row = 0; row < size; row++) { for(int column = 0; column < size; column++) if(targetNumber[row][column] != -1) { string str = (new StringBuilder()).append(targetNumber[row][column]).append(operator[row][column]).toString(); g2.drawString(str, xOffset + column * cellSize + 5, yOffset + row * cellSize + 17); }   }   g2.setStroke(thin); g2.setFont(new font("Dialog", 0, 32)); for(int row = 0; row < size; row++) { for(int column = 0; column < size; column++) if(numbers[row][column] != -1 && numbers[row][column] != 0) { g2.setColor(numColors[row][column]); string str = (new StringBuilder()).append(numbers[row][column]).toString(); g2.drawString(str, xOffset + column * cellSize + 22, yOffset + row * cellSize + 45); }   }   }   private void checkRowColumn() { for(int row = 0; row < size; row++) { for(int column = 0; column < size; column++) { int currentNumber = numbers[row][column]; for(int i = 0; i < size; i++) if(i != column && currentNumber == numbers[row][i]) { numColors[row][column] = color.red; numColors[row][i] = color.red; }   for(int i = 0; i < size; i++) if(i != row && currentNumber == numbers[i][column]) { numColors[row][column] = color.red; numColors[i][column] = color.red; }   }   }   }   private void checkCages() { for(int i = 0; i < numCages; i++) { arraylist list = new arraylist(); for(int row = 0; row < size; row++) { for(int column = 0; column < size; column++) if(cages[row][column] == i) list.add(integer.valueOf(numbers[row][column]));   }   if(!isValid(list, i)) { for(int row = 0; row < size; row++) { for(int column = 0; column < size; column++) if(cages[row][column] == i) numColors[row][column] = color.red;   }   } }   }   private arraylist permutation(arraylist list) { arraylist result = new arraylist(); int numElements = list.size(); if(numElements == 0) { result.add(new arraylist()); return result; } for(int i = 0; i < numElements; i++) { arraylist clonedList = new arraylist(); for(int j = 0; j < list.size(); j++) clonedList.add(j, (integer)list.get(j));   integer removedEntry = (integer)clonedList.remove(i); arraylist tempList = permutation(clonedList); int numTempList = tempList.size(); for(int j = 0; j < numTempList; j++) { arraylist x = (arraylist)tempList.remove(0); x.add(0, removedEntry); result.add(x); }   }   return result; }   public boolean isValid(arraylist cageList, int cageNumber) { arraylist allLists = permutation(cageList); int numAllLists = allLists.size(); for(int i = 0; i < numAllLists; i++) { arraylist currentList = (arraylist)allLists.get(i); int numEntries = currentList.size(); int tempResult = ((integer)currentList.get(0)).intValue(); for(int j = 1; j < numEntries; j++) if(cageOperator[cageNumber] == '+') tempResult += ((integer)currentList.get(j)).intValue(); else if(cageOperator[cageNumber] == '-') tempResult -= ((integer)currentList.get(j)).intValue(); else if(cageOperator[cageNumber] == '*') tempResult *= ((integer)currentList.get(j)).intValue(); else if(cageOperator[cageNumber] == '/') { if(tempResult % ((integer)currentList.get(j)).intValue() != 0) tempResult = 0; tempResult /= ((integer)currentList.get(j)).intValue(); }   if(cageTargetNumber[cageNumber] == tempResult) return true; }   return false; }   private boolean bottom[][]; private boolean right[][]; private int numbers[][]; private color numColors[][]; private int cages[][]; private int cageTargetNumber[]; private int size; private int numCages; private int targetNumber[][]; private char operator[][]; private char cageOperator[]; private int xOffset; private int yOffset; private int cellSize; private basicstroke thin; private basicstroke thick; }


